//
// 用最少数量的箭引爆气球（中等-452）
// 中文链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons
//
// 问题描述：
// 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。
// 由于它是水平的，所以 y 坐标并不重要，因此只要知道开始和结束的x坐标就足够了。
// 开始坐标总是小于结束坐标。平面内最多存在 104 个气球。
// 一支弓箭可以沿着 x 轴从不同点完全垂直地射出。
// 在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x_start，x_end， 且满足 x_start ≤ x ≤ x_end，则该气球会被引爆。
// 可以射出的弓箭的数量没有限制。弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
//
// 示例:
// 输入:
// [[10,16], [2,8], [1,6], [7,12]]
// 输出:
// 2
// 解释:
// 对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。
//
// @author Ls J
// @date 8/20/20 9:35 PM
//
package greedy

import "sort"

//
// 贪心算法，尽量使每一只箭能够射到更多的气球
// 我们可以先根据气球结束位置的坐标进行排序，然后跟踪气球的结束坐标：
// 1. 若下个气球开始坐标在当前气球的结束坐标前，则我们可以用一支箭一起引爆；
// 2. 若下个气球的开始坐标在当前气球的结束坐标后，则我们必须增加箭的数量，并跟踪下个气球的结束坐标。
//
// 执行用时：84 ms，在所有 Go 提交中击败了 89.58% 的用户
// 内存消耗：7 MB，在所有 Go 提交中击败了 92.86% 的用户
//
// @param points [][2]int points
// @return min arrows
//
func findMinArrowShots(points [][]int) int {
    n := len(points)

    if n == 0 {
        return 0
    }
    // 按照结束位置排序，每次射箭的时候都尽可能穿过更多的气球
    sort.Slice(points, func(i, j int) bool {
        return points[i][1] < points[j][1]
    })

    res, end := 1, points[0][1]

    for _, point := range points {
        // [0,1]，[2,3]，没有相交，那么此时需要增加一支箭才行
        if point[0] > end {
            res++
            end = point[1]
        }
    }

    return res
}

