[TOC]

# RPC 之架构设计

RPC 本质上就是一个远程调用，

## 服务发现

## 健康检测

有了集群之后，在每次发请求之前，RPC 框架都会根据负载均衡算法选择一个具体的服务提供者的实例以供调用。为了保证能够请求成功，我们需要确保每次选择的服务提供者（一个 IP 地址）是健康的。因为，我们需要一个完善的健康检测机制，能够及时发现服务集群中不健康的节点，并且能够及时告知服务的调用方。

### 基于心跳的健康检测

健康检测最常见的解决方案是基于心跳的健康检测。

## 路由策略

## 负载均衡

一般情况下 RPC 的负载均衡完全由 RPC 框架自身来实现，RPC 的服务调用者会与“注册中心”下发的所有服务节点建立长连接，在每次发起 RPC 调用的时候，服务调用者都会通过配置的负载均衡算法自主选择一个节点，发起 RPC 调用请求。

主流的负载均衡算法有随机权重法、轮询法、最小连接法以及（一致性）哈希算法等。

### （一致性）哈希算法

无论是随机权重还是轮询算法，对于一个服务调用方的多次请求，每次落到的提供方很大概率上是不同的。如果请求是无状态的，那么影响不大，但如果请求是有状态的，比如带有缓存服务等，如果请求不到一台服务器上，那么对于缓存的同步将是很大的一个挑战（当然通过分布式缓存，例如 Redis 等，可以很大程度上解决这一问题）。针对这个问题，哈希算法就可以派上用场了。

哈希算法的核心思想是设计一个哈希函数，然后请求过来之后，首先通过哈希函数计算的结果选择对应的调用节点，需要注意的是函数的参数对于特定的请求应该是一致的，比如唯一 ID 等，这样能够确保计算出来的结果是完全一致的。但是哈希算法适合处理节点数量相对比较固定的场景，因为如果一旦出现节点的增加或者删除，那么整个哈希函数可能都需要重写，因为要保证结果不会落到已被删除的节点上或者要能够落到新增的节点上，这个时候可能会产生大量的数据迁移。一致性哈希算法在这种场景之下孕育而生。

一致性哈希算法是指将服务器节点映射到一个首尾相连的哈希环上面，在经过哈希函数计算之后，会从哈希环上面进行顺时针查找，直到找到第一个对应的节点。这样当某个节点宕机或新增节点的时候，受影响的仅仅是此节点和此节点前一个节点的数据，这样数据迁移的成本会大大降低，并且节点数越多，迁移成本就会越低。所以一致性算法具有较好的容错性和可扩展性。

但是在一致性哈希中，经常会出现一种情况：调用方访问请求集中在少数的几个节点上，会出现有些服务提供方负载较高，而另外一些提供方负载较低的情况，因为我们很难设计出一个每个节点之间的间隔在哈希环上是基本一致的，就算设计出来了，如果新增或删除节点，这种基本一致也会被破坏。为了解决这个问题，一致性哈希算法中又引入了虚拟节点的概念。它的大致思想就是针对每个服务器节点计算多个哈希值，在每个计算结果的位置上，都放置一个虚拟节点，并且将虚拟节点映射到实际节点上，这样能够很大程度上使节点在哈希环上的分布相对一致。

## 异常重试

## 优雅关闭

在服务重启或者关机的过程中，服务的调用方可能会存在以下几种情况：

- 调用方发请求之前，目标服务已经下线了。对于调用方来说，跟目标节点的连接会断开，这个时候调用方可以立马感知到，并且在其健康列表里面把这个节点移除，从而不会被负载均衡算法选中。这是我们希望看到的一点。
- 调用方发请求的时候，目标服务正在关闭，但调用方并不知道它正在关闭，而且两者之间的连接也没有断开，这个节点还会在健康列表里面，因此该节点有一定的概率会被选中，并且有可能在请求处理还没有结束的时候服务就已经下线了，如果这个时候在执行事务操作等，那就很有可能会导致事务的不一致，这对于线上业务的影响是很大的。

服务下线的过程中，会有两次 RPC 调用，一是服务提供方通知注册中心下线操作，另外一个是注册中心通知调用方服务节点的下线，但是由于注册中心通知服务方是异步的，不能保持实时性，只能保证最终一致性，所以注册中心在收到服务提供方下线的时候，并不能成功保证把这次要下线的节点推送到所有的调用方。

因此为了避免上述第二种情况的出现，我们需要一个能够优雅地关闭服务的机制。

想要优雅地关闭服务，我们需要从两方面考虑，一方面是对于即将到来的请求要怎么办，另一方面是对于正在处理中的请求要怎么办。接下来我们就从这两方面来具体展开。

### 处理即将到来并且还没有处理的请求

因为服务方已经开始进入关闭流程了，那么很多对象可能已经被销毁了，关闭过程中再收到的请求肯定是没法按照正常的业务逻辑来进行处理的，因此我们需要在关闭的时候设置一个“挡板”，它的作用就是告诉调用方“我已经开始进入关闭流程了，你的请求我不能再处理了”。

基于这个思路，我们可以这么处理：当服务提供方正在关闭，如果这个时候还收到了新的请求，提供方直接返回一个特定的异常给调用方，这个异常告诉调用方“我收到了请求，但是我正在关闭，并没有处理它”，此时调用方收到这个异常响应之后，它会把请求重试到其他节点，并且 RPC 框架会直接把这个节点从健康列表中移除掉。

但是以上的方法只是一种被动等待的方式，也就是说，只有请求过来了才会通知相应的调用方。这会导致整个关闭的过程有些漫长，因为在当前时间点有的调用方可能会没有业务请求。因此除此之外，我们还可以加入一个主动通知的流程。

那么如何能够捕获到关闭事件呢？答案就是通过捕获操作系统的进程信号来获取。在 Java 语言中，对应的就是 Runtime.addShutdownHook 方法，可以注册关闭的钩子。在 RPC 启动的时候，我们提前注册关闭钩子，并在里面添加了两个处理程序，一个负责开启关闭标识，一个负责安全关闭服务对象，服务对象在关闭的时候会通知调用方下线节点。同时需要在我们调用链里面加上挡板处理器，当新的请求来的时候，会判断关闭标识，如果正在关闭，则抛出特定异常。

### 处理正在进行中的请求

对于正在处理中的请求，我们首先需要能够识别出这些请求，并且能够知道请求数量。对此我们可以在服务对象上面添加一个计数器，如果有请求过来了，计数器加一，请求处理完成之后，计数器减一，通过该计数器我们就可以知道是否还有正在处理中的请求了。

### 总结

在 RPC 里面，服务重启（关闭）看似是一个不起眼的小功能，但是如果处理的不好的话，极有可能会导致业务受损，通过优雅关闭流程，我们可以不用再担心因为重启而导致的问题，减少了许多运维成本。

## 优雅启动--启动预热

在 Java 里面，运行过程中，JVM 会把高频的代码编译成机器码，被加载过的类也会被缓存到 JVM 缓存中，再次使用的时候不会触发临时加载，这就导致在 Java 进程刚刚启动的时候，执行速度会比已经运行了一段时间的时候要慢。因此在服务刚启动的时候就承担着停机前一样的流量，会使它在启动之初就处于高负载的状态，从而导致调用方过来的请求可能出现大面的超时，进而使线上业务受损。

因此，对于服务的启动，我们也应该有一个机制，让它不会在启动之初承担大量流量，而是一开始只接受少许请求，然后逐渐提升到最佳状态，这就是 RPC 中的“启动预热”。

### 启动预热

在整个 RPC 框架中，服务调用是由服务调用方通过一定的负载均衡算法发起的，因此在进行负载均衡的时候，调用方需要能够区分刚刚启动的服务，从而降低选取到它的概率。那么要怎么区分一个服务是否为刚启动不久呢？这里主要有两种方案，都很简单。第一种方案，是服务提供方在启动的时候，把自己的启动时间告诉注册中心；另外一种方案就是注册中心在调用方注册的时候记录一下它的注册请求时间。通过这两种方案，最终的结果都是调用方通过服务发现的时候，不但能够找到所有的可用服务列表，还包括它们的启动时间，然后通过这个启动时间计算一个权值交给负载均衡算法去计算即可。

### 延迟暴露

在服务启动的过程中，都通过执行 main() 方法，顺序地把各种相关的依赖加载进来。这个时候，如果加载到了 RPC 服务相关的依赖，那么就会同时把它注册到注册中心。此时，就有可能会存在调用方已经能够从注册中心拿到该服务，但是此服务却还没有完全启动完成的情况，从而有可能会导致请求调用失败，业务受损。“延迟暴露”的概念就是为了解决该问题而出现的。

在应用启动加载、解析 Bean 的时候，如果遇到了 RPC 服务的 Bean，只先把这个 Bean 注册到 Spring-BeanFactory 里面去，而并不把这个 Bean 对应的接口注册到注册中心，只有等应用启动完成后，才把接口注册到注册中心用于服务发现，从而实现让服务调用方延迟获取到服务提供方地址。同时我们可以在服务提供方应用启动后，接口注册到注册中心前，预留一个 Hook 过程，让用户可以实现可扩展的 Hook 逻辑。用户可以在 Hook 里面模拟调用逻辑，从而使 JVM 指令能够预热起来，并且用户也可以在 Hook 里面事先预加载一些资源，只有等所有的资源都加载完成后，最后才把接口注册到注册中心，这样的话对于调用方来说，服务列表中的每一个服务都是一致的状态，从而可以不考虑服务的启动时间，简化负载均衡逻辑。

### 总结

启动预热与延迟暴露并不是 RPC 的专属功能，我们在开发其它系统时，也可以利用这两点来减少冷启动对业务的影响。

## 熔断限流

## 业务分组






