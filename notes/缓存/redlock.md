## Redis -- Redlock

标签（空格分隔）： redis redlock

---

### 单点 Redis 模式下锁的获取

在加锁过程中，一定要保证其具有原子性，也就是说设置 KV 以及对应的过期时间应该是同步完成的，或者说要保证在应用异常或者重启的时候，不能出现 KV 设置好了，但是过期时间还没有来得及设置，这会导致该锁无法过期。

保证原子性的方法有两个：

- 使用 Lua 脚本：它包含 setnx 和 expire 两条指令，setnx（SET IF NOT Exists） 意思是在 key 不存在的时候再执行 set 操作；expire 是设置其过期时间
- 使用 set key value [EX seconds][PX milliseconds][NX|XX]，其中：
    - EX seconds: 设定过期时间，单位为秒
    - PX milliseconds: 设定过期时间，单位为毫秒
    - NX: 仅当key不存在时设置值
    - XX: 仅当key存在时设置值

在设置锁的操作中，要保证 value 具有唯一性，也就是说要使用随机字符串而不能全程使用一个固定值，这样做是为了能够更安全的释放锁。假如 value 不是随机字符串，而是一个固定的值，那么就有可能会出现以下问题：

- 1.客户端 A 获取到了锁
- 2.客户端 A 在某个操作上阻塞了很久
- 3.客户端 A 设置的锁过期了，锁被自动释放
- 4.客户端 B 获取到了同一个 key 的锁
- 5.客户端 A 阻塞操作完成，由于两次加锁的 key/value 是一样的，所以客户端 A 可以成功释放掉客户端 B 加的锁，这肯定是有问题的

因此，在锁释放的过程中，正确的操作是先检查锁存不存在，再检查对应的 value 是不是自己加锁时的 value，如果 value 一致，那么就执行响应的删除操作。所以可以看到这里有获取、判断 value 值、删除三个操作，同时最好也保证其原子性。

在单机 Redis 下，上述的加锁方法完全正确，但是在集群模式下，由于节点间的同步问题，上述操作并不能完全保证加锁成功，有可能会出现多个客户端同时获取到锁的情况。

比如说客户端 A 在 Redis 的 master 节点上拿到了锁，但是这个加锁的 key 还没有同步到 slave 节点，master 故障，发生故障转移，一个 slave 节点升级为 master 节点，客户端 B 也可以获取同个 key 的锁，但客户端 A 也已经拿到锁了，这就导致多个客户端都拿到了锁。

针对以上问题，Redis 的作者开发出了 Redlock。

### Redis 集群模式下锁的获取 -- Redlock

这里的集群意思要么是 n 个 redis 单实例，要么是 n 个 sentinel 集群，要么是 n 个 cluster 集群。而不是一个有 n 个主节点的 cluster 集群。

Redis 集群有三种方式：

- 主从模式：保证数据在从节点还有一份，但是主节点挂了之后，需要手动把从节点切换为主节点。它非常简单，但是在实际的生产环境中是很少使用的。
- 哨兵模式：主从模式的升级版，该模式下会对响应异常的主节点进行主观下线或者客观下线的操作，并进行主从切换。它可以保证高可用。
- cluster（集群）模式：保证高并发，整个集群分担所有数据，不同的 key 会放到不同的 Redis 中。每个 Redis 对应一部分的槽。

基于 Redlock，一个客户端如果要获取到锁，需要经过以下五个步骤：

- 1.获取当前 Unix 时间，以毫秒为单位。
- 2.依次尝试从 N 个实例，使用相同的 key 和随机值获取锁。在步骤 2，当向 Redis 设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 Redis 已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个 Redis 实例。
- 3.客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。
- 4.如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。
- 5.如果因为某些原因，获取锁失败（没有在至少 N/2+1 个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁（即便某些 Redis 实例根本就没有加锁成功）。

通过以上几个步骤，只要大多数的节点可以正常工作，就可以保证 Redlock 的正常工作。这样就可以解决前面单点 Redis 的情况下我们讨论的节点挂掉，由于异步通信，导致锁失效的问题。

之所以步骤三要进行一次时间减法运算，是为了防止加锁过程中由于网络延迟以及应用阻塞（G等C）等原因，导致客户端拿到锁的时候，其实锁已经过期了的情况。

但其实上述过程并不能解决故障重启后带来的锁的安全性的问题，比如考虑以下场景：

我们一共有 A、B、C 三个节点：

- 客户端 1 在 A，B 上加锁成功。C 上加锁失败
- 这时节点 B 崩溃重启了，但是由于持久化策略导致客户端 1 在 B 上的锁没有持久化下来
- 客户端 2 发起申请同一把锁的操作，在 B，C 上加锁成功
- 这个时候就又出现同一把锁，同时被客户端 1 和客户端 2 所持有了

当然我们可以更改持久化策略，设置成每次修改数据都进行 fsync 操作，但这样会大大降低 Redis 的性能，而且就算如此，由于系统环境复杂，每次 fsync 之后也并不能保证不会丢失数据。为了解决这一问题，Redis 作者提出了延迟重启的概念，意思就是一个节点崩溃之后，不立即重启它，而是等待一段时间再去重启，且这个等待的时间应该大于锁的过期时间，这样做的目的是保证这个节点在重启前所参与的锁都过期。但是如果同一时刻宕机的 Redis 节点比较多，那么则会大大增加剩余节点的负载，更严重的则可能会导致整个集群崩溃。

关于 Redlock 的更多特点与不足，我们可以参考引文[1]中大佬的描述。

Redisson 是 Redlock Java 客户端的一种实现，通过它，能够很轻松的执行加锁操作，可以参考[Redisson实现Redis分布式锁的N种姿势](https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ)这篇文章。

如果想要实现更健壮的分布式锁，我们可以使用 ZooKeeper。

### 参考
- [1][【求锤得锤的故事】Redis锁从面试连环炮聊到神仙打架](https://mp.weixin.qq.com/s?__biz=MzIxNTQ4MzE1NA==&mid=2247485308&idx=1&sn=8c86565e3ec4dac33d52b375dbab120a&chksm=9796d101a0e1581762560cb7f56cc1dd5379b10a629ea3b5f67c118b7731329255c027dde9fc&scene=21#wechat_redirect)
- [2] [基于 Redis 的分布式锁的实现](https://juejin.im/post/5cc165816fb9a03202221dd5)
- [3] [Redlock 获取锁过程（官网）](http://redis.cn/topics/distlock.html)
- [4] [Martin 对 Redlock 的质疑](http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)
- [5] [Antirez 对 Martion 质疑的回应](http://antirez.com/news/101)



